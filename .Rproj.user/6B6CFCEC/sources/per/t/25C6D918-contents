#Running Questions bar
# What do these variables actually mean?
# Which ones would be best to track? Which is the best indicator of overall business performance?
# How can we ingest lots more data? Can we get local data?


# COnditions
# We used all good data, no collinearity
# Summed up values per day
# Took a ts() for freq = 365, observing a yearly trend
# Tested against a quarter and 2-quarter lead
# More parameters than experimental variables--good or bad?

library(tidyverse)
library(mice)
library(lubridate)

library(Quandl)
library(Hmisc)
library(corrplot)

KDARaw <- read_csv("data/Keaton Data Analysis Project-2016-2020.csv",
                   na = c("", "-", "--", "---", "	 -   ", " -   ", " ", "  "), 
                   skip = 1, trim_ws = TRUE, col_names = TRUE)

colnames(KDARaw) <- (c("Date", "DealNum", "VStock", "Year", "Make",
                       "Model", "NU", "Front_Gross_Profit", "Back_Gross_Profit",
                       "Total_Gross_Profit", "Cash_Price", "PL", "Sale_Type",
                       "Salesman", "Salesmanager", "FIManager"))

#remove parenthesis and change parse
pear<- function(x){
  x<- gsub("[()]", "", x)
  x<- gsub(" ", "", x)
  x<- gsub(",", "", x)
  x<- as.numeric(x)
}
KDARaw$Front_Gross_Profit<-pear(KDARaw$Front_Gross_Profit)
KDARaw$Back_Gross_Profit<-pear(KDARaw$Back_Gross_Profit)
KDARaw$Total_Gross_Profit<- pear(KDARaw$Total_Gross_Profit)
KDARaw$Cash_Price<-pear(KDARaw$Cash_Price)

KDARaw$Date<-as.Date(KDARaw$Date, format = "%m/%d/%Y")

#check date
class(KDARaw$Date)
class(KDARaw$Front_Gross_Profit)

KDARaw<- arrange(KDARaw, Date)

summary(KDARaw)
str(KDARaw)

head(KDARaw)
tail(KDARaw)

#test df
KDAt<-KDARaw

#3058 omitted values from back_gross_profit
#205 from front
#38  from total
#251 from cash price

#####

#Some quick EDA

######

#quick plots
plot(KDARaw$Date,KDARaw$Front_Gross_Profit)
plot(KDARaw$Date,KDARaw$Back_Gross_Profit)
plot(KDARaw$Date,KDARaw$Total_Gross_Profit)
plot(KDARaw$Date,KDARaw$Cash_Price)
###########
#Some trend exploration for Make
unique(KDAt$Make)
ggplot(KDAt, aes(Make)) + theme(axis.text = element_text(angle = 90)) + geom_bar()
#Nwow filter out Chevy Mazda and Kia
filter(KDAt, Make == c("CHEV", "MAZD", "KIA")) %>%
         ggplot() + 
  geom_smooth(aes(x = Date, y = Total_Gross_Profit, color = Make)) 

###ggplot(filter(KDAt, Make == c("CHEV", "MAZD", "KIA")), 
###       aes(Date, Front_Gross_Profit/n)) +
###  geom_smooth(aes(col = Make), se = T) + facet_wrap(facets = KDA1$Make)


#New/Used
ggplot() + geom_smooth(data = filter(KDAt, NU== c("USED", "NEW")), 
                       aes(x = Date, y = Total_Gross_Profit, color = NU)) +
         geom_point(data = filter(KDAt, NU == "S"), aes(Date, Total_Gross_Profit, color = NU))


# To roll up by day, we'll just omit missing values: shouldn't be a big deal for 
#all but Back_Gross_Profit --which we will not use cause it'll be hard to estimate
#such a large chunk of data (more than %15)

#Roll up by day and by day per sale
#lots of missing days
by.day <- group_by(KDAt, Date) %>%
  mutate(date = Date,
         fgp = sum(Front_Gross_Profit, na.rm = T),
         tgp = sum(Total_Gross_Profit, na.rm = T),
         cp = sum(Cash_Price, na.rm = T),
         n = length(NU)) %>%
  ungroup()%>%
  summarise(date, fgp,tgp, cp, n) %>%
  unique()

bd.by.sale <- group_by(KDAt,Date) %>%
  mutate(date = Date,
         fgp.a = sum(Front_Gross_Profit)/length(NU),
         tgp.a = sum(Total_Gross_Profit)/length(NU),
         cp.a = sum(Cash_Price)/length(NU)) %>%
  ungroup() %>%
  summarise(date, fgp.a, tgp.a, cp.a) %>%
  unique()

#Check it out
plot(by.day)
plot(bd.by.sale)
#1727 days, but there should be 1782

rogue<-full_join(by.day, bd.by.sale)

#Add the missing days
time.seq<-seq.Date(from = as.Date("2016-01-01"), 
                   to = as.Date("2020-11-16"), by = 'day')
blank<-as.data.frame(time.seq)
colnames(blank)<-c("date")

Day<-left_join(blank, rogue)
plot(Day)
#Are these randomly distributed?
a<-which(is.na(Day$tgp.a))
hist(a, main = "NAs in Day.1", xlab= "Day number")
#The whole month of April 2020 is gone, so we cant really do anything with it
#2020-03-26 : 2020-04-30
# we will impute without these values for now ###
Day.1<-filter(Day, date < "2020-03-26")

#Imputation first:: Unit multiple imputation for 55 missing days
imp <- mice(data = Day.1, print = F)
Day.1.c<-complete(imp)

#check NAs again and return to day
cran <-90
cran.2<-180
which(is.na(Day.1.c))
Day <- Day.1.c
Day <- mutate(Day,
                fgp.lead = lead(fgp, cran),
                tgp.lead = lead(tgp, cran),
                cp.lead = lead(cp, cran),
                n.lead = lead(n, cran),
                fgp.a.lead = lead(fgp.a, cran),
                tgp.a.lead = lead(tgp.a, cran),
                cp.a.lead = lead(cp.a, cran),
                
                fgp.lead.6 = lead(fgp, cran.2),
                tgp.lead.6 = lead(tgp, cran.2),
                cp.lead.6 = lead(cp, cran.2),
                n.lead.6 = lead(n, cran.2),
                fgp.a.lead.6 = lead(fgp.a, cran.2),
                tgp.a.lead.6 = lead(tgp.a, cran.2),
                cp.a.lead.6 = lead(cp.a, cran.2))

#Now we get trends
Day.t<-as.data.frame(lapply(2:ncol(Day.1.c), FUN = function(i) 
  Day.1.c[, i] <- decompose(ts(Day.1.c[i], frequency = 365))$trend)) %>%
  mutate(date = Day.1.c$date)
colnames(Day.t)<-c('fgp', 'tgp', 'cp', 'n', 'fgp.a', 'tgp.a', 'cp.a', 'date')
#change order and get rid of NAs
Day.t <-select(Day.t,  date, fgp, tgp, cp, n, fgp.a, tgp.a, cp.a)
# we need to lag these trends by a quarter
# We'll set the interval to first be 90 days and then 180

Day.t<-mutate(Day.t,
  fgp.lead = lead(fgp, cran),
  tgp.lead = lead(tgp, cran),
  cp.lead = lead(cp, cran),
  n.lead = lead(n, cran),
  fgp.a.lead = lead(fgp.a, cran),
  tgp.a.lead = lead(tgp.a, cran),
  cp.a.lead = lead(cp.a, cran),
  
  fgp.lead.6 = lead(fgp, cran.2),
  tgp.lead.6 = lead(tgp, cran.2),
  cp.lead.6 = lead(cp, cran.2),
  n.lead.6 = lead(n, cran.2),
  fgp.a.lead.6 = lead(fgp.a, cran.2),
  tgp.a.lead.6 = lead(tgp.a, cran.2),
  cp.a.lead.6 = lead(cp.a, cran.2)
)
summary(Day.t)


#and by month
cran <-3
cran.2<-6
Month <- group_by(Day.1.c, date = floor_date(date, "month")) %>%
  summarise(date, fgp = sum(fgp),
         tgp = sum(tgp),
         cp = sum(cp),
         n = sum(n),
         fgp.a = sum(fgp)/n,
         tgp.a = sum(tgp)/n,
         cp.a = sum(cp)/n) %>%
         
  summarise(date, fgp, tgp, cp, n, fgp.a, tgp.a, cp.a) %>%
  unique()
Month <- mutate(Month, fgp.lead = lead(fgp, cran),
             tgp.lead = lead(tgp, cran),
             cp.lead = lead(cp, cran),
             n.lead = lead(n, cran),
             fgp.a.lead = lead(fgp.a, cran),
             tgp.a.lead = lead(tgp.a, cran),
             cp.a.lead = lead(cp.a, cran),
             
             fgp.lead.6 = lead(fgp, cran.2),
             tgp.lead.6 = lead(tgp, cran.2),
             cp.lead.6 = lead(cp, cran.2),
             n.lead.6 = lead(n, cran.2),
             fgp.a.lead.6 = lead(fgp.a, cran.2),
             tgp.a.lead.6 = lead(tgp.a, cran.2),
             cp.a.lead.6 = lead(cp.a, cran.2))


#get trend
Month.t <- as.data.frame(lapply(2:8, FUN = function(i) 
  Month[, i] <- decompose(ts(Month[i], frequency = 12))$trend)) %>%
  mutate(date = Month$date)
colnames(Month.t) <- c('fgp', 'tgp', 'cp', 'n', 'fgp.a', 'tgp.a', 'cp.a', 'date')

Month.t <- mutate(Month.t, fgp.lead = lead(fgp, cran),
                  tgp.lead = lead(tgp, cran),
                  cp.lead = lead(cp, cran),
                  n.lead = lead(n, cran),
                  fgp.a.lead = lead(fgp.a, cran),
                  tgp.a.lead = lead(tgp.a, cran),
                  cp.a.lead = lead(cp.a, cran),
                  
                  fgp.lead.6 = lead(fgp, cran.2),
                  tgp.lead.6 = lead(tgp, cran.2),
                  cp.lead.6 = lead(cp, cran.2),
                  n.lead.6 = lead(n, cran.2),
                  fgp.a.lead.6 = lead(fgp.a, cran.2),
                  tgp.a.lead.6 = lead(tgp.a, cran.2),
                  cp.a.lead.6 = lead(cp.a, cran.2))

#Fix blank
time.seq<-seq.Date(from = as.Date("2016-01-01"), 
                   to = as.Date("2020-03-25"), by = 'day')
blank<-as.data.frame(time.seq)
colnames(blank)<-c("date")
blank.m<-as.data.frame(seq.Date(from = as.Date("2016-01-01"), 
                                to = as.Date("2020-03-25"), by = 'month'))
colnames(blank.m)<-c("date")


#SUM _ by day raw
Day %>%
ggplot(aes(x = date, y = .6*tgp-600)) + geom_line(aes(color = "total gross"), se = FALSE) + 
  geom_line(aes(x = date, y = .6*fgp + 8700, color = "front gross"), se = FALSE) +
  geom_line(aes(x = date, y = .15*(cp-183000), color = "cash price"), se = FALSE) +
  geom_line(aes(x = date, y = 1000*n+5000, color = "n sales"), se = FALSE) + ylab("") +
  ggtitle("Raw (normalized without ts)")
#vs.extracted trend
Day.t %>%
  ggplot(aes(x = date, y = .6*tgp-600)) + geom_line(aes(color = "total gross")) + 
  geom_line(aes(x = date, y = .6*fgp + 8700, color = "front gross")) +
  geom_line(aes(x = date, y = .05*cp, color = "cash price")) +
  geom_line(aes(x = date, y = 1000*n+5000, color = "n sales")) + ylab("") + 
  ggtitle("Trend (normalized with ts)")

#Average per sale
Day.t %>%
  ggplot(aes(x = date, y = tgp.a-700)) + geom_line(aes(color = "total gross avg")) +
  geom_line(aes(x = date, y = fgp.a, color = "front gross avg")) +
  geom_line(aes(x = date, y = .05*cp.a, color = "cash price avg")) +
  geom_line(aes(x = date, y = 100*n, color = "n sales")) + ylab("") + 
  ggtitle("Average per Sale (normalized with ts)")

#Average _ per sale by day normalized

#Lets get some data: from 2016-01-01 to 2020-03-25
#Start Very Broad
#QUANDL?


#OPEC crude oil
oil<-Quandl(code = "OPEC/ORB", collapse = 'daily', 
            start_date="2016-01-01", end_date="2020-03-25", force_irregular = TRUE)
oil<-left_join(blank, oil, by =  c("date" = "Date"))

ggplot(Day.t, aes(date, tgp, color = "LJ")) + geom_line() +
  geom_line(data = oil, aes(date, Value + 16000, color = "OPEC")) + geom_line()

rcorr(as.matrix(select(Day.t, -c('date'))), oil$Value)

#GM data
GM <-read.csv("data/GM.csv")
GM$Date<-as.Date(GM$Date)
GM <- left_join(blank, GM, by = c("date" = c("Date")))
a<-rcorr(as.matrix(select(Day.t, -c('date'))), GM$Adj.Close)
ggplot() + geom_line(data = Day.t, aes(date, fgp.lead/max(fgp.lead, na.rm = T))) + 
  geom_line(data = GM, aes(date, Adj.Close/max(Adj.Close, na.rm = T)))
print(a)
### function dev
#  we want to use day and month

  
  #ggplot(Kib.f) + geom_line(
  #                     aes(x = date, y = x/max(x, na.rm = T), color = "y")) +
  #  geom_line(aes(x = date, y = cp.a/max(cp.a, na.rm = T), color = "cp.a")) +  ylab("Value") +
  #  ggtitle(names(data[y]), "vs. fgp.lead")
# More data
#Analysis.R
